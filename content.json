[{"title":"javascript数据类型","date":"2021-03-08T09:59:24.000Z","path":"2021/03/08/js-basic-data-type/","text":"请注意：JS的数据类型有8种 一、JS数据类型的结构在ES5的时候，我们所知晓的数据类型有6种：Number、String、Boolean、undefined、Null、object。ES6中新增一种Symbol，这种类型的对象永不相等，即使创建的时候传入相同的值，可以用来解决属性名冲突的问题，作为标记。谷歌67版本还出现了一种bigInt，是指安全存储、操作大整数。 根据上面描述，我们可以整理出对应如下的结构图： 可以将js的8中数据类型拆分为3个大类：基本数据类型 + 对象类型 + 其他类型然后基本数据类型包含：Number、String、Boolean、undefined、Null，对象类型(object)包含：function、array、date 二、实际场景下，容易混淆的情况2.1 JS中typeof输入分别是什么 typeof {} 与 typeof [] 输出的都是object； typeof console.info 输出的是function； 有一点需要注意：NaN是Number中的一种，非Number 关于isNaN的注意点 用isNaN()检测是否是非数值类型，如下图： Number(‘123’) == NaN?，这里Number(‘123’)输出的是123，123是不等于NaN的，因此为false 三、如何判断数据类型？3.1 上面有提及到3.2 toString()函数作用：其他类型转成string的方法支持的数据类型有：number、boolean、string、object不支持的数据类型有：null、undefined 3.3 toLocalString()函数作用：将数组转成本地字符串 3.4 检测数据类型的方法 instanceof 操作符 对象的constructor属性 Array.isArray()检查数据是否为数组 四、null与undefined有什么区别？Null只有一个值，是null，一个不存在的对象；undefined只有一个值，是undefined，没有初始化，undefined是从null中派生出来的。简单理解就是：undefined是没有定义的，null就是定义了变量，但没有给变量赋值。 五、== 与 === 有什么区别，一般在什么场景下使用？==：表示相同。比较的是物理地址，相当于比较两个对象的hashCode，肯定不相等的。类型不相同，值也可能相等。比如 ‘1’ == 1 为true；===：表示严格相同，严格判断类型是否相同。 六、总结： undefined类型，只有一个值，在使用var/let/const来声明变量但为对其进行初始化的时候，这个变量就是undefined; null类型，只有一个值，null表示一个空对象指针，这也就是为毛typeof null返回的是object的原因； Boolean类型，只有true/false两个值，true不一定等于1，false不一定等于0； Number类型，数字类型，表示数据的整数和浮点数 String类型，字符串，可用单引号也可以用双引号表示，字符串不可改变(一般任何的基本数据类型都是不可改变的)，改变某个变量保存的字符串，首先要销毁原来的字符串，然后用另一个字符串来填充。 Object类型， ES5中的对象其实就是一组数据和函数的集合体，对象可以通过new操作符来创建，创建object类型的实例并为其添加属性或方法，就可以自定义创建对象，如下：1let obj = new Object(); object的每个实例都有以下属性和方法： 属性名称 类型 作用 constructor function 保存着用于创建当前对象的函数，构造函数constructor就是object() hasOwnProperty(propertyName) function 用于检查给定的propertyName属性是否在当前对象实例中，而不是在他的原型中 isPrototypeOf(Object) function 用于检查传入的对象是否是对象原型 propertyIsEnumerable(propertyName) function 属性是否可被枚举，是否可以被使用for-in语句 toLocaleString() function 返回对象的执行环境地区字符串表示 toString() function 返回对象的字符串表示 valueOf() function 返回对象的字符串表示，通常与toString返回的一致"},{"title":"编码规范","date":"2021-03-08T07:05:10.000Z","path":"2021/03/08/code-rule-mag/","text":"一、css规范1.1 css命名规则1. class 必须单词全字母小写，单词间以 - 分隔。 2. class 必须代表相应模块或部件的内容或功能，不得以样式信息进行命名。 1.2 属性顺序 位置属性(position、top、right、z-index、display、float等)； 大小(width, height, padding, margin等)； 文字系列(font、line-height、letter-spacing、color、text-align等)； 背景(background、border等)； 其他(animation、transition等) 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; 1.3 选择器如无必要不得为 id、class 选择器添加类型选择器进行限定，在性能和维护性上，都有一定的影响。 1234567891011/* 推荐*/#error,.danger-message &#123; font-color: #c00;&#125;/* 不推荐*/dialog#error,p.danger-message &#123; font-color: #c00;&#125; 1.4 多个选择器公用相同属性时1234567891011/* 推荐 */ .post, .page, .comment &#123; line-height: 1.5; &#125; /* 不推荐 */ .post, .page, .comment &#123; line-height: 1.5; &#125; 二、JS规范2.1 文件命名文件夹和文件名的命名应该能代表代码功能，与后端一致为佳。 2.2 语言规范 变量声明变量必须加上 let、const、var 关键字.当你没有写 let、const、var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么,变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 let、const 、var去声明变量. 分号总是使用分号如果仅依靠语句间的隐式分隔, 有时会很麻烦. 你自己更能清楚哪里是语句的起止,而且有些情况下，漏掉分号会很危险。 for-in 循环最好只用于 object/map/hash 的遍历对 Array 用 for-in 循环有时会出错. 因为它并不是从 0 到 length - 1 进行遍历, 而是所有出现在对象及其原型链的键值.例如：给原型添加属性之后，默认情况下枚举，最后输出1234513 123456789function getNewArrayTwo()&#123; var array=[1,2,3,4,5 ]; Array.prototype.age=13; var result=[]; for(var i in array)&#123; result.push(array[i]); &#125; alert(result.join(&#x27;&#x27;)); &#125; 三、编码风格3.1 明确作用域任何时候都要明确作用域 – 提高可移植性和清晰度. 例如, 不要依赖于作用域链中的 window 对象.可能在其他应用中, 你函数中的 window 不是指之前的那个窗口对象。 3.2 代码格式化数组和对象的初始化,如果初始值不是很长, 就保持写在单行上: 1234567891011121314151617181920var arr = [1, 2, 3]; // No space after [ or before ].var obj = &#123;a: 1, b: 2, c: 3&#125;; // No space after &#123; or before &#125;. 初始值占用多行时, 缩进2个空格. // Object initializer. var inset = &#123; top: 10, right: 20, bottom: 15, left: 12 &#125;; // Array initializer. this.rows_ = [ &#x27;&quot;Slartibartfast&quot; &lt;fjordmaster@magrathea.com&gt;&#x27;, &#x27;&quot;Zaphod Beeblebrox&quot; &lt;theprez@universe.gov&gt;&#x27;, &#x27;&quot;Ford Prefect&quot; &lt;ford@theguide.com&gt;&#x27;, &#x27;&quot;Arthur Dent&quot; &lt;has.no.tea@gmail.com&gt;&#x27;, &#x27;&quot;Marvin the Paranoid Android&quot; &lt;marv@googlemail.com&gt;&#x27;, &#x27;the.mice@magrathea.com&#x27; ]; 3.3 引号的使用单引号 (‘) 优于双引号 (“).当你创建一个包含 HTML 代码的字符串时就知道它的好处了。 3.4 过长的单行予以换行换行应选择在操作符和标点符号之后。 12345 if (oUser.nAge &lt; 30 &amp;&amp; oUser.bIsChecked === true || oUser.sName === &#x27;admin&#x27;) &#123; // code&#125; 四、vue规范4.1 vue属性书写顺序1234567891011121314151617181920212223export default &#123; //不要忘记了 name 属性 name: &#x27;RangeSlider&#x27;, //组合其它组件 extends: &#123;&#125;, //组件属性、变量 props: &#123; bar: &#123;&#125;, // 按字母顺序 foo: &#123;&#125;, fooBar: &#123;&#125;, &#125;, // 变量 data() &#123;&#125;, computed: &#123;&#125;, //使用其它组件 components: &#123;&#125;, // 方法 watch: &#123;&#125;, methods: &#123;&#125;, // 生命周期函数 beforeCreate() &#123;&#125;, mounted() &#123;&#125;,&#125; 4.2组件组件以驼峰命名 以及书写顺序 123456789101112 &lt;template&gt; &lt;my-components&gt;&lt;/my-components&gt; &lt;/template&gt;&lt;script&gt; import myComponents from &#x27;./myComponents.vue&#x27; export default &#123; components: &#123; myComponents &#125; &#125;&lt;/script&gt; 4.3 组件引用123456789101112import myComponentsA from &#x27;./myComponentsA.vue&#x27; import myComponentsB from &#x27;./myComponentsB.vue&#x27;import myComponentsC from &#x27;./myComponentsC.vue&#x27;import myComponentsD from &#x27;./myComponentsD.vue&#x27;export default &#123; components: &#123; myComponentsA, myComponentsB, myComponentsC, myComponentsD, &#125;&#125; 4.4 事件12345 &lt;!-- 不建议 --&gt;&lt;a v-on:click=&quot;pass()&quot;&gt;pass&lt;/a&gt;&lt;!-- 推荐 --&gt;&lt;a @click=&quot;pass&quot;&gt;pass&lt;/a&gt; 4.5 vue页面使用每个 vue 页面中的最外层template下面只能有一个标签12345678910// error&lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;// right&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt; 4.6 vue返回上一页12this.$router.go(-1) //就可以回到上一页。history.go(-1) //是回到浏览器上一页，但是由于Vue应用是单页应用，浏览器的访问历史未必和Vue的浏览历史相同。 4.7 通过路由跳转，传递查询内容1234this.$router.push(&#123; path: &quot;/path&quot;, query:&#123;query:queryThings&#125;&#125;) 4.8 methods 自定义方法命名 动宾短语（good：jumpPage、openCarInfoDialog）（bad：go、nextPage、show、open、login） ajax 方法以 get、post 开头，以 data 结尾（good：getListData、postFormData）（bad：takeData、confirmData、getList、postForm） 事件方法以 on 开头（onTypeChange、onUsernameInput） init、refresh 单词除外 尽量使用常用单词开头（set、get、open、close、jump） 驼峰命名（good: getListData）（bad: get_list_data、getlistData） 4.9 路由的命名path和name使用相同的命名 1234567891011 示例：&#123; path: &#x27;/merchandise&#x27;, //路由路径 icon: &#x27;key&#x27;, //icon图标 name: &#x27;merchandise&#x27;, //路由名称 title: &#x27;商品&#x27;, //路由标题 access: 0, //权限代码 component: main, children: [ &#123; path: &#x27;merchandise-pubish&#x27;, title: &#x27;商品发布&#x27;, name: &#x27;merchandise-pubish&#x27;, component: () =&gt; import(&#x27;@/views/merchandise/pubish.vue&#x27;) &#125;, ]&#125; 五、注释规范5.1 页面注释规范 页面中使用注释划分结构块，注意与css中的注释达成统一格式。 12345678910111213 &lt;!-- 头部 --&gt;&lt;div class=&quot;g-hd&quot;&gt; &lt;!-- LOGO --&gt; &lt;h1 class=&quot;m-logo&quot;&gt;&lt;a hred=&quot;#&quot;&gt;LOGO&lt;/a&gt;&lt;/h1&gt; &lt;!-- /LOGO --&gt; &lt;!-- 导航 --&gt; &lt;ul class=&quot;m-nav&quot;&gt; &lt;li&gt;&lt;a hred=&quot;#&quot;&gt;NAV1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a hred=&quot;#&quot;&gt;NAV2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- /导航 --&gt;&lt;/div&gt;&lt;!-- /头部 --&gt; 5.2 函数注释123456789101112 /*** 简述** 功能详细描述** @param &lt;String&gt; arg1 参数1* @param &lt;Number&gt; arg2 参数2，默认为0* @return &lt;Boolean&gt; 判断xxx是否成功*/function fooFunction (arg1, arg2) &#123; // code&#125; 5.3语句注释12345678 #单独一行 //(双斜线)与注释文字之间保留一个空格； #在代码后面添加注释：//(双斜线)与代码之间保留一个空格，并且//(双斜线)与注释文字之间保留一个空格； #//(双斜线)与代码之间保留一个空格。 // 调用了一个函数；1)单独在一行setTitle();var maxCount = 10; // 设置最大量；2)在代码后面注释// setName(); // 3)注释代码"},{"title":"通过verdaccio服务搭建内部npm管理","date":"2021-03-08T06:17:01.000Z","path":"2021/03/08/verdaccio-custom-npm/","text":"关于如何要共享组件？目前公司的前端项目比较多，涉及到中后台业务系统，有存在不少组件，在不同的业务系统中使用的，为了避免疯狂的ctrl +C &gt; ctrl + V，一堆的维护工作，这边搭建了内部的私有源，又不能将公司的一个资源扔到公共的npm上，因此这边利用verdaccio + gitlab来搭建以及维护蜘点前端公共的组件服务，通过verdaccio来管理组件的上传以及可视化管理，gitlab来管理组件的版本以及迭代，满足组件的更新迭代； 一、为啥子要使用私有源呢 加快共有npm包的安装速度； 避免本地npm install指向源，避免cnpm等其他源拉取npm包不及时的问题； 私有源会将已经使用的npm包缓存下来，提升个人本地/打包环境npm包的安装速度； 把公共代码上传到私有源，可以在多个git仓库项目中通过npm的方式来使用； A仓库 封装了一个 video组件，想给B仓库使用。那就可以制作一个 video组件仓库，然后发布到 私有源上。A和B仓库使用的时候就 npm install 组件库，let api = require(‘组件库’) 啦~ 这个步骤和 发公有npm包是一模一样的，只是发的位置不一样而已。 二、通过verdaccio服务，搭建内部npm管理 访问verdaccio官网按照这个一步一步来就行 如果是本地电脑 不需要改 verdaccio的 config.yaml配置文件，如果是服务器部署，那你需要改 config.yaml的配置 我们这里按服务器部署为例子 你需要先安装上 shell node npm pm2 shell npm install -g verdaccio 创建一个 非root的账户 在此账户下 执行verdaccio，且找到 config.yaml文件 要在内部机器上运行，因此，需要这是局域网访问，vim修改config.yaml，新增一行，保存：1listen: 0.0.0.0:4873 verdaccis 跑一下，显示一下内容就正常了； 三、日常使用–切换npm源 由于内部npm也是使用的npm来管理，因此，需要一专门的工具，来管理源的切换； 打开命令行工具，安装npm切换源的快捷工具npm/nrm：shell npm install -g nrm 输入命令：shell nrm ls，可以看到以下截图，前面有个小星星的，代表当前源是指向哪里的 输入命令：shell nrm add 源名称 源地址，创建一个新的源 输入命令：shell nrm use 源名字，切换使用的源 四、日常使用 切换使用的源； 通过npm安装依赖即可； 结束至此，整个内部npm的使用以及发布就已经全部说明完成了，无论团队的开发者/使用者来说，只要用nrm将源切换为私有源就可以了。verdaccio通过代理的形式，把私有包和官方包且分开；"},{"title":"Hexo + github + netlify搭建自己的博客系统","date":"2021-03-07T08:27:48.000Z","path":"2021/03/07/hexo-github-netify/","text":"一、开始使用1.1简介根据Hexo官方描述，Hexo是一个快速、简介且高效的博客框架，使用markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.2安装1.2.1环境需求 Node.js(版本不得低于10.13，建议使用Node.js12.0及以上) Git 以上两个就不在描述具体如何安装了，度娘一大把 1.3 Hexo安装1npm install -g hexo 二、开始使用2.1 创建博客项目，并初始化安装完成后，可直接通过hexo创建并初始化项目，通过以下命令 1hexo init blog 通过上述命令，我们创建并初始化了项目名为blog的Hexo项目 1cd blog &amp;&amp; npm install 2.2 目录结构分析说明进入blog项目，并安装相关的依赖，通过以下示意图我们可以简单的讲解下项目的目录结构，以及对应的文件作用： .deploy_git: 通过github进行打包部署，所生成的待提交的静态资源文件； scaffold: 通过new命令创建出来的页面所需的模版，默认是拿的page作为模版； source: 通过new命令创建出来的页面资源的*.md文件目录，一般我们创建的页面，都在这个目录里面，按照new命令对应的标题来命名的； themes：引用的三方样式，可直接通过配置文件，引用第三方已开发完成并使用中的模版； _config.yml：整个blog项目的配置文件，从整体上对项目进行全局配置； 2.3 项目配置文件说明_config.yml为项目的全局配置文件，一般我们通过配置该文件，对项目整体上进行统一的配置，具体对应哪些字段就不再重复说明了，官方文档上已经解说得很清楚的了，详情请直接访问官方的 链接 2.3.1 上线部署的配置1234deploy: type: git # 通过git方式来提交 repo: https://github.com/kbmjj123/hexo-blog.git # 关联github仓库 branch: main #代码分支 三、Hexo命令解读：官方对Hexo的相关命令均进行了详细的说明，具体可以浏览官方的链接进行熟悉； 四、开始写作：4.1 通过命令创建一新的页面1hexo new page 文件名称 // 如果文件名称由多个字符串构成，需要使用引号将文件名称包裹起来 4.2 通过上述命令，我们可以在对应的source/_posts目录中，看到我们添加的文件目录以及对应的*.md文件4.3 写作完成后，进行资源文件生成，并发布1hexo g &amp;&amp; hexo d // g为generate、d为deploy的缩写 这里生成后的资源，均会在.deploy_get目录中生成对应的资源文件，并自动提交至github上，前提是已经在本地将github的key给维护进来了。 五、托管到Netlify5.1 注册Netlify打开链接进行netlify的注册，并选择代码托管的方式来注册 5.2 创建新的Site，并选择github作为来源 5.3 然后选择我们刚刚在github上创建的项目 5.4 选择对应的项目分支 5.5 接着等一会，netlify会帮我们创建对应的网站，并生成其二级域名 5.6 添加项目域名 5.7 配合下拉弹出的记录值，到域名注册服务商那边，对应配置记录对应登录阿里云控制台，找到域名，对应进入解析配置中心，并对应添加两条记录： 5.8 解析成功后，我们即可以直接使用自定义域名的方式，来直接访问到我们的blog了"},{"title":"Hexo安装与配置服务升级","date":"2021-03-04T03:31:31.631Z","path":"2021/03/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]